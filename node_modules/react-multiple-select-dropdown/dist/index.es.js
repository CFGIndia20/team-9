import { PureComponent, createElement, Fragment, createRef, Component } from 'react';
import { array, arrayOf, func, number, object, oneOf, oneOfType, string } from 'prop-types';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

// import styled from '@emotion/styled'
// export const AppWrap = styled.div<{ breackPoint: "575" | "768" | "991" | "1199" }>`
// .multiple-select--mobile{
//     display: none;
//   }
//     @media (max-width: ${(props) => props.breackPoint}px) {
//         .multiple-select--desktop{
//           display: none;
//         }
//         .multiple-select--mobile{
//             display: block;
//           }
//       }
// `
// export const SelectWrap = styled.div`
//     display: flex;
// `;
// export const SummaryWrap = styled.div`
//     flex-grow: 1;
//     text-overflow: ellipsis;
//     white-space: nowrap;
//     overflow: hidden;
//     transition: border-color 0.3s ease;
//     line-height: 28px;
//     position: absolute;
//     width: 100%;
// `;
// export const Summary = styled.div`
//     position: relative;
// `;
// export const Trigger = styled.div`
//     width: 100%;
// 	height: 30px;
// 	border: none;
// 	background-color: transparent;
//     border-bottom: 2px solid #e6e6e6;
//     input {
//         outline: none;
//         height: auto;
//         border: none;
//     }
// `;
// export const ListsWrap = styled.div`
//     box-shadow: 0 0 12px 0px rgba(0, 0, 0, 0.5);
//     &.dark {
//         // background-color: #24292e;
//         .multiple-select_list {
//             -webkit-overflow-scrolling: touch;
//             background-color: #24292e;
//         }
//         .multiple-select_list_item li{
//             color: #ffffff;
//         }
//         .multiple-select_list_item .svg-point {
//             fill: #ffffff;
//         }
//         .multiple-select_list_item:hover {
//             background-color: #4d4d4d;
//         }
//         .multiple-select_list_item.js-active{
//             background-color: #333333;
//         }
//         .multiple-select_list_item-add, .multiple-select_list_item-remove-all li {
//             color: #ffffff;
//             background-color: #24292e;
//             .svg-point {
//                 fill: #ffffff;
//             }
//         }
//     }
// `;
// export const ListsInner = styled.div`
//     display: flex;
// `;
// export const TabHeader = styled.div`
//     display: flex;
// 	background-color: #FFFFFF;
// 	border-bottom: 2px solid #95B5BB;
//     height: 32px;
//     span {
//         padding: 6px;
//     }
//     &.js-active {
//         background-color: #95B5BB;
//         color: #fff;
// }`;
// export const List = styled.div`
//     width: 240px;
// 	height: 200px;
// 	font-size: 14px;
// 	font-weight: 300;
// 	overflow: auto;
// 	max-height: 300px;
// 	width: 240px;
// 	background-color: transparent;
//     z-index: 1000;
// `;
// export const ListItem = styled.div`
//     border-radius: 25px;
//     &:hover {
//     	background-color: #F2F2F2;
//     }
//     &.js-active {
//     	background-color: #E8E8E8;
//     }
//     li {
// 	position: relative;
// 	font-size: 13px;
// 	min-height: 25px;
// 	display: flex;
// 	align-items: center;
// 	font-size: 13px;
// 	margin: 5px 5px 5px 5px;
// 	padding: 5px 10px;
//     }
//     li > * {
//     	display: inline-block;
//     	width: 100%;
//     	overflow: hidden;
//         text-overflow: ellipsis;
//     }
// `;
// export const ItemAdd = styled.div`
//     display: flex;
// 	align-items: center;
// 	justify-content: flex-end;
// 	border-bottom: 2px solid #CCCCCC;
// 	padding: 8px 0;
// 	margin-right: 20px;
// 	background-color: #FFFFFF;
// 	color: #F58229;
// 	font-weight: 500;
// 	font-size: 13px;
// 	width: 100%;
// 	z-index: 1000;
//     cursor: pointer;
//     svg {
//         width: 24px;
//         height: 24px;
//     }
//     .svg-point {
//         fill: #F58229;
//     }
//     .icon {
//         order: 1;
//         display: inline-block;
//         padding-left: 8px;
//     }
//     span {
//         order: 2;
//     }
// `;
// export const HeaderItem = styled.div`
//     display: flex;
// 	justify-content: center;
// 	align-items: center;
// 	padding: 8px;
// 	flex: 1;
// 	font-size: 13px;
//     cursor: pointer;
//     &.js-active {
//         background-color: #95B5BB;
// 	    color: #fff;
//     }
// `;
// export const RemoveAll = styled.div`
//     display: flex;
// 	align-items: center;
// 	justify-content: flex-end;
// 	border-bottom: 2px solid #CCCCCC;
// 	padding: 8px 0;
// 	margin-right: 20px;
// 	background-color: #FFFFFF;
// 	color: #F58229;
// 	font-weight: 500;
// 	font-size: 13px;
// 	width: 100%;
// 	z-index: 1000;
//     cursor: pointer;
//     svg {
//         width: 24px;
//         height: 24px;
//     }
//     .svg-point {
//         fill: #F58229;
//     }
//     .icon {
//         order: 1;
//         display: inline-block;
//         padding-left: 8px;
//     }
//     span {
//         order: 2;
//     }
// `;
// export const UnSelectedList = styled(List)`
//     .multiple-select_list_item li{
//     	justify-content: flex-start;
//     	align-items: center;
//     }
//     &.js-addable .multiple-select_list_item{
//     	top: 50px;
//     }
// `;
// export const SelectedList = styled(List)`
//     .multiple-select_list_item{
//     	justify-content: center;
//     	align-items: center;
//     }
//     .icon--trash {
//     	padding-right: 10px;
//     	text-align: end;
//     }
//     .icon--trash svg {
//     	width: 15px;
//     	height: 15px;
//     }
//     .icon--trash .svg-point {
//     	fill: #F58229;
//     }
//     &.js-show-remove-all .multiple-select_list_item{
//     	top: 50px;
//     }
// `;
var DropDownWrap = function (_a) {
    var top = _a.top, className = _a.className, children = _a.children;
    return (createElement("div", { className: className, style: {
            position: 'absolute',
            top: top + "px"
        } }, children));
};

var PlusIcon = /** @class */ (function (_super) {
    __extends(PlusIcon, _super);
    function PlusIcon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    PlusIcon.prototype.render = function () {
        return (createElement("div", __assign({}, this.props, { className: 'icon icon--plus' + (this.props.className ? ' ' + this.props.className : '') }),
            createElement("svg", { viewBox: "0 0 11.15 11.15" },
                createElement("path", { className: "svg-point", d: "M10.22,4.65H6.51V.93a.93.93,0,1,0-1.86,0V4.65H.93a.93.93,0,0,0,0,1.86H4.65v3.71a.93.93,0,0,0,1.86,0V6.51h3.71a.93.93,0,0,0,0-1.86Z" }))));
    };
    return PlusIcon;
}(PureComponent));

// tslint:disable: max-line-length
var TrashIcon = /** @class */ (function (_super) {
    __extends(TrashIcon, _super);
    function TrashIcon() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TrashIcon.prototype.render = function () {
        return (createElement("div", __assign({}, this.props, { className: "icon icon--trash" +
                (this.props.className ? " " + this.props.className : "") }),
            createElement("svg", { viewBox: "0 0 11.49 14.54" },
                createElement("path", { className: "svg-point", d: "M10.5,1.71H8.56V.45A.46.46,0,0,0,8.1,0a.06.06,0,0,0,0,0L8,0H3.39a.45.45,0,0,0-.45.45V1.71H1a1,1,0,0,0-1,1V4.32H.86v9.23a1,1,0,0,0,1,1H9.65a1,1,0,0,0,1-1V4.32h.85V2.7A1,1,0,0,0,10.5,1.71ZM3.84.9H7.65v.81H3.84ZM9.73,13.55c0,.06,0,.08-.08.08H1.84c-.05,0-.08,0-.08-.08V4.32h8Zm.85-10.13H.91V2.7c0-.05,0-.09.08-.09H10.5c.06,0,.08,0,.08.09Z" }),
                createElement("rect", { className: "svg-point", x: "7.39", y: "5.38", width: "0.91", height: "7.45" }),
                createElement("rect", { className: "svg-point", x: "5.3", y: "5.38", width: "0.91", height: "7.45" }),
                createElement("rect", { className: "svg-point", x: "3.2", y: "5.38", width: "0.91", height: "7.45" }))));
    };
    return TrashIcon;
}(PureComponent));

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics$1 = function(d, b) {
    extendStatics$1 = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics$1(d, b);
};

function __extends$1(d, b) {
    extendStatics$1(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

function __rest$1(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

var ALIGNMENT;
(function (ALIGNMENT) {
    ALIGNMENT["AUTO"] = "auto";
    ALIGNMENT["START"] = "start";
    ALIGNMENT["CENTER"] = "center";
    ALIGNMENT["END"] = "end";
})(ALIGNMENT || (ALIGNMENT = {}));
var DIRECTION;
(function (DIRECTION) {
    DIRECTION["HORIZONTAL"] = "horizontal";
    DIRECTION["VERTICAL"] = "vertical";
})(DIRECTION || (DIRECTION = {}));
var SCROLL_CHANGE_REASON;
(function (SCROLL_CHANGE_REASON) {
    SCROLL_CHANGE_REASON["OBSERVED"] = "observed";
    SCROLL_CHANGE_REASON["REQUESTED"] = "requested";
})(SCROLL_CHANGE_REASON || (SCROLL_CHANGE_REASON = {}));
var scrollProp = (_a = {}, _a[DIRECTION.VERTICAL] = 'scrollTop', _a[DIRECTION.HORIZONTAL] = 'scrollLeft', _a);
var sizeProp = (_b = {}, _b[DIRECTION.VERTICAL] = 'height', _b[DIRECTION.HORIZONTAL] = 'width', _b);
var positionProp = (_c = {}, _c[DIRECTION.VERTICAL] = 'top', _c[DIRECTION.HORIZONTAL] = 'left', _c);
var marginProp = (_d = {}, _d[DIRECTION.VERTICAL] = 'marginTop', _d[DIRECTION.HORIZONTAL] = 'marginLeft', _d);
var oppositeMarginProp = (_e = {}, _e[DIRECTION.VERTICAL] = 'marginBottom', _e[DIRECTION.HORIZONTAL] = 'marginRight', _e);
var _a;
var _b;
var _c;
var _d;
var _e;

/* Forked from react-virtualized ðŸ’– */
var SizeAndPositionManager = /** @class */function () {
    function SizeAndPositionManager(_a) {
        var itemCount = _a.itemCount,
            itemSizeGetter = _a.itemSizeGetter,
            estimatedItemSize = _a.estimatedItemSize;
        this.itemSizeGetter = itemSizeGetter;
        this.itemCount = itemCount;
        this.estimatedItemSize = estimatedItemSize;
        // Cache of size and position data for items, mapped by item index.
        this.itemSizeAndPositionData = {};
        // Measurements for items up to this index can be trusted; items afterward should be estimated.
        this.lastMeasuredIndex = -1;
    }
    SizeAndPositionManager.prototype.updateConfig = function (_a) {
        var itemCount = _a.itemCount,
            itemSizeGetter = _a.itemSizeGetter,
            estimatedItemSize = _a.estimatedItemSize;
        if (itemCount != null) {
            this.itemCount = itemCount;
        }
        if (estimatedItemSize != null) {
            this.estimatedItemSize = estimatedItemSize;
        }
        if (itemSizeGetter != null) {
            this.itemSizeGetter = itemSizeGetter;
        }
    };
    SizeAndPositionManager.prototype.getLastMeasuredIndex = function () {
        return this.lastMeasuredIndex;
    };
    /**
     * This method returns the size and position for the item at the specified index.
     * It just-in-time calculates (or used cached values) for items leading up to the index.
     */
    SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function (index) {
        if (index < 0 || index >= this.itemCount) {
            throw Error("Requested index " + index + " is outside of range 0.." + this.itemCount);
        }
        if (index > this.lastMeasuredIndex) {
            var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
            var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;
            for (var i = this.lastMeasuredIndex + 1; i <= index; i++) {
                var size = this.itemSizeGetter(i);
                if (size == null || isNaN(size)) {
                    throw Error("Invalid size returned for index " + i + " of value " + size);
                }
                this.itemSizeAndPositionData[i] = {
                    offset: offset,
                    size: size
                };
                offset += size;
            }
            this.lastMeasuredIndex = index;
        }
        return this.itemSizeAndPositionData[index];
    };
    SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function () {
        return this.lastMeasuredIndex >= 0 ? this.itemSizeAndPositionData[this.lastMeasuredIndex] : { offset: 0, size: 0 };
    };
    /**
     * Total size of all items being measured.
     * This value will be completedly estimated initially.
     * As items as measured the estimate will be updated.
     */
    SizeAndPositionManager.prototype.getTotalSize = function () {
        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
        return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this.itemCount - this.lastMeasuredIndex - 1) * this.estimatedItemSize;
    };
    /**
     * Determines a new offset that ensures a certain item is visible, given the alignment.
     *
     * @param align Desired alignment within container; one of "start" (default), "center", or "end"
     * @param containerSize Size (width or height) of the container viewport
     * @return Offset to use to ensure the specified item is visible
     */
    SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function (_a) {
        var _b = _a.align,
            align = _b === void 0 ? ALIGNMENT.START : _b,
            containerSize = _a.containerSize,
            currentOffset = _a.currentOffset,
            targetIndex = _a.targetIndex;
        if (containerSize <= 0) {
            return 0;
        }
        var datum = this.getSizeAndPositionForIndex(targetIndex);
        var maxOffset = datum.offset;
        var minOffset = maxOffset - containerSize + datum.size;
        var idealOffset;
        switch (align) {
            case ALIGNMENT.END:
                idealOffset = minOffset;
                break;
            case ALIGNMENT.CENTER:
                idealOffset = maxOffset - (containerSize - datum.size) / 2;
                break;
            case ALIGNMENT.START:
                idealOffset = maxOffset;
                break;
            default:
                idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
        }
        var totalSize = this.getTotalSize();
        return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
    };
    SizeAndPositionManager.prototype.getVisibleRange = function (_a) {
        var containerSize = _a.containerSize,
            offset = _a.offset,
            overscanCount = _a.overscanCount;
        var totalSize = this.getTotalSize();
        if (totalSize === 0) {
            return {};
        }
        var maxOffset = offset + containerSize;
        var start = this.findNearestItem(offset);
        if (typeof start === 'undefined') {
            throw Error("Invalid offset " + offset + " specified");
        }
        var datum = this.getSizeAndPositionForIndex(start);
        offset = datum.offset + datum.size;
        var stop = start;
        while (offset < maxOffset && stop < this.itemCount - 1) {
            stop++;
            offset += this.getSizeAndPositionForIndex(stop).size;
        }
        if (overscanCount) {
            start = Math.max(0, start - overscanCount);
            stop = Math.min(stop + overscanCount, this.itemCount - 1);
        }
        return {
            start: start,
            stop: stop
        };
    };
    /**
     * Clear all cached values for items after the specified index.
     * This method should be called for any item that has changed its size.
     * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.
     */
    SizeAndPositionManager.prototype.resetItem = function (index) {
        this.lastMeasuredIndex = Math.min(this.lastMeasuredIndex, index - 1);
    };
    /**
     * Searches for the item (index) nearest the specified offset.
     *
     * If no exact match is found the next lowest item index will be returned.
     * This allows partially visible items (with offsets just before/above the fold) to be visible.
     */
    SizeAndPositionManager.prototype.findNearestItem = function (offset) {
        if (isNaN(offset)) {
            throw Error("Invalid offset " + offset + " specified");
        }
        // Our search algorithms find the nearest match at or below the specified offset.
        // So make sure the offset is at least 0 or no match will be found.
        offset = Math.max(0, offset);
        var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();
        var lastMeasuredIndex = Math.max(0, this.lastMeasuredIndex);
        if (lastMeasuredSizeAndPosition.offset >= offset) {
            // If we've already measured items within this range just use a binary search as it's faster.
            return this.binarySearch({
                high: lastMeasuredIndex,
                low: 0,
                offset: offset
            });
        } else {
            // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.
            // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.
            // The overall complexity for this approach is O(log n).
            return this.exponentialSearch({
                index: lastMeasuredIndex,
                offset: offset
            });
        }
    };
    SizeAndPositionManager.prototype.binarySearch = function (_a) {
        var low = _a.low,
            high = _a.high,
            offset = _a.offset;
        var middle = 0;
        var currentOffset = 0;
        while (low <= high) {
            middle = low + Math.floor((high - low) / 2);
            currentOffset = this.getSizeAndPositionForIndex(middle).offset;
            if (currentOffset === offset) {
                return middle;
            } else if (currentOffset < offset) {
                low = middle + 1;
            } else if (currentOffset > offset) {
                high = middle - 1;
            }
        }
        if (low > 0) {
            return low - 1;
        }
        return 0;
    };
    SizeAndPositionManager.prototype.exponentialSearch = function (_a) {
        var index = _a.index,
            offset = _a.offset;
        var interval = 1;
        while (index < this.itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {
            index += interval;
            interval *= 2;
        }
        return this.binarySearch({
            high: Math.min(index, this.itemCount - 1),
            low: Math.floor(index / 2),
            offset: offset
        });
    };
    return SizeAndPositionManager;
}();

var STYLE_WRAPPER = {
    overflow: 'auto',
    willChange: 'transform',
    WebkitOverflowScrolling: 'touch'
};
var STYLE_INNER = {
    position: 'relative',
    width: '100%',
    minHeight: '100%'
};
var STYLE_ITEM = {
    position: 'absolute',
    top: 0,
    left: 0,
    width: '100%'
};
var STYLE_STICKY_ITEM = __assign$1({}, STYLE_ITEM, { position: 'sticky' });
var VirtualList = /** @class */function (_super) {
    __extends$1(VirtualList, _super);
    function VirtualList() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.itemSizeGetter = function (itemSize) {
            return function (index) {
                return _this.getSize(index, itemSize);
            };
        };
        _this.sizeAndPositionManager = new SizeAndPositionManager({
            itemCount: _this.props.itemCount,
            itemSizeGetter: _this.itemSizeGetter(_this.props.itemSize),
            estimatedItemSize: _this.getEstimatedItemSize()
        });
        _this.state = {
            offset: _this.props.scrollOffset || _this.props.scrollToIndex != null && _this.getOffsetForIndex(_this.props.scrollToIndex) || 0,
            scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
        };
        _this.styleCache = {};
        _this.getRef = function (node) {
            _this.rootNode = node;
        };
        _this.handleScroll = function (event) {
            var onScroll = _this.props.onScroll;
            var offset = _this.getNodeOffset();
            if (offset < 0 || _this.state.offset === offset || event.target !== _this.rootNode) {
                return;
            }
            _this.setState({
                offset: offset,
                scrollChangeReason: SCROLL_CHANGE_REASON.OBSERVED
            });
            if (typeof onScroll === 'function') {
                onScroll(offset, event);
            }
        };
        return _this;
    }
    VirtualList.prototype.componentDidMount = function () {
        var _a = this.props,
            scrollOffset = _a.scrollOffset,
            scrollToIndex = _a.scrollToIndex;
        this.rootNode.addEventListener('scroll', this.handleScroll, {
            passive: true
        });
        if (scrollOffset != null) {
            this.scrollTo(scrollOffset);
        } else if (scrollToIndex != null) {
            this.scrollTo(this.getOffsetForIndex(scrollToIndex));
        }
    };
    VirtualList.prototype.componentWillReceiveProps = function (nextProps) {
        var _a = this.props,
            estimatedItemSize = _a.estimatedItemSize,
            itemCount = _a.itemCount,
            itemSize = _a.itemSize,
            scrollOffset = _a.scrollOffset,
            scrollToAlignment = _a.scrollToAlignment,
            scrollToIndex = _a.scrollToIndex;
        var scrollPropsHaveChanged = nextProps.scrollToIndex !== scrollToIndex || nextProps.scrollToAlignment !== scrollToAlignment;
        var itemPropsHaveChanged = nextProps.itemCount !== itemCount || nextProps.itemSize !== itemSize || nextProps.estimatedItemSize !== estimatedItemSize;
        if (nextProps.itemSize !== itemSize) {
            this.sizeAndPositionManager.updateConfig({
                itemSizeGetter: this.itemSizeGetter(nextProps.itemSize)
            });
        }
        if (nextProps.itemCount !== itemCount || nextProps.estimatedItemSize !== estimatedItemSize) {
            this.sizeAndPositionManager.updateConfig({
                itemCount: nextProps.itemCount,
                estimatedItemSize: this.getEstimatedItemSize(nextProps)
            });
        }
        if (itemPropsHaveChanged) {
            this.recomputeSizes();
        }
        if (nextProps.scrollOffset !== scrollOffset) {
            this.setState({
                offset: nextProps.scrollOffset || 0,
                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
            });
        } else if (typeof nextProps.scrollToIndex === 'number' && (scrollPropsHaveChanged || itemPropsHaveChanged)) {
            this.setState({
                offset: this.getOffsetForIndex(nextProps.scrollToIndex, nextProps.scrollToAlignment, nextProps.itemCount),
                scrollChangeReason: SCROLL_CHANGE_REASON.REQUESTED
            });
        }
    };
    VirtualList.prototype.componentDidUpdate = function (_, prevState) {
        var _a = this.state,
            offset = _a.offset,
            scrollChangeReason = _a.scrollChangeReason;
        if (prevState.offset !== offset && scrollChangeReason === SCROLL_CHANGE_REASON.REQUESTED) {
            this.scrollTo(offset);
        }
    };
    VirtualList.prototype.componentWillUnmount = function () {
        this.rootNode.removeEventListener('scroll', this.handleScroll);
    };
    VirtualList.prototype.scrollTo = function (value) {
        var _a = this.props.scrollDirection,
            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;
        this.rootNode[scrollProp[scrollDirection]] = value;
    };
    VirtualList.prototype.getOffsetForIndex = function (index, scrollToAlignment, itemCount) {
        if (scrollToAlignment === void 0) {
            scrollToAlignment = this.props.scrollToAlignment;
        }
        if (itemCount === void 0) {
            itemCount = this.props.itemCount;
        }
        var _a = this.props.scrollDirection,
            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;
        if (index < 0 || index >= itemCount) {
            index = 0;
        }
        return this.sizeAndPositionManager.getUpdatedOffsetForIndex({
            align: scrollToAlignment,
            containerSize: this.props[sizeProp[scrollDirection]],
            currentOffset: this.state && this.state.offset || 0,
            targetIndex: index
        });
    };
    VirtualList.prototype.recomputeSizes = function (startIndex) {
        if (startIndex === void 0) {
            startIndex = 0;
        }
        this.styleCache = {};
        this.sizeAndPositionManager.resetItem(startIndex);
    };
    VirtualList.prototype.render = function () {
        var _this = this;
        var _a = this.props,
            estimatedItemSize = _a.estimatedItemSize,
            height = _a.height,
            _b = _a.overscanCount,
            overscanCount = _b === void 0 ? 3 : _b,
            renderItem = _a.renderItem,
            itemCount = _a.itemCount,
            itemSize = _a.itemSize,
            onItemsRendered = _a.onItemsRendered,
            onScroll = _a.onScroll,
            _c = _a.scrollDirection,
            scrollDirection = _c === void 0 ? DIRECTION.VERTICAL : _c,
            scrollOffset = _a.scrollOffset,
            scrollToIndex = _a.scrollToIndex,
            scrollToAlignment = _a.scrollToAlignment,
            stickyIndices = _a.stickyIndices,
            style = _a.style,
            width = _a.width,
            props = __rest$1(_a, ["estimatedItemSize", "height", "overscanCount", "renderItem", "itemCount", "itemSize", "onItemsRendered", "onScroll", "scrollDirection", "scrollOffset", "scrollToIndex", "scrollToAlignment", "stickyIndices", "style", "width"]);
        var offset = this.state.offset;
        var _d = this.sizeAndPositionManager.getVisibleRange({
            containerSize: this.props[sizeProp[scrollDirection]] || 0,
            offset: offset,
            overscanCount: overscanCount
        }),
            start = _d.start,
            stop = _d.stop;
        var items = [];
        var wrapperStyle = __assign$1({}, STYLE_WRAPPER, style, { height: height, width: width });
        var innerStyle = __assign$1({}, STYLE_INNER, (_e = {}, _e[sizeProp[scrollDirection]] = this.sizeAndPositionManager.getTotalSize(), _e));
        if (stickyIndices != null && stickyIndices.length !== 0) {
            stickyIndices.forEach(function (index) {
                return items.push(renderItem({
                    index: index,
                    style: _this.getStyle(index, true)
                }));
            });
            if (scrollDirection === DIRECTION.HORIZONTAL) {
                innerStyle.display = 'flex';
            }
        }
        if (typeof start !== 'undefined' && typeof stop !== 'undefined') {
            for (var index = start; index <= stop; index++) {
                if (stickyIndices != null && stickyIndices.includes(index)) {
                    continue;
                }
                items.push(renderItem({
                    index: index,
                    style: this.getStyle(index, false)
                }));
            }
            if (typeof onItemsRendered === 'function') {
                onItemsRendered({
                    startIndex: start,
                    stopIndex: stop
                });
            }
        }
        return createElement("div", __assign$1({ ref: this.getRef }, props, { style: wrapperStyle }), createElement("div", { style: innerStyle }, items));
        var _e;
    };
    VirtualList.prototype.getNodeOffset = function () {
        var _a = this.props.scrollDirection,
            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;
        return this.rootNode[scrollProp[scrollDirection]];
    };
    VirtualList.prototype.getEstimatedItemSize = function (props) {
        if (props === void 0) {
            props = this.props;
        }
        return props.estimatedItemSize || typeof props.itemSize === 'number' && props.itemSize || 50;
    };
    VirtualList.prototype.getSize = function (index, itemSize) {
        if (typeof itemSize === 'function') {
            return itemSize(index);
        }
        return Array.isArray(itemSize) ? itemSize[index] : itemSize;
    };
    VirtualList.prototype.getStyle = function (index, sticky) {
        var style = this.styleCache[index];
        if (style) {
            return style;
        }
        var _a = this.props.scrollDirection,
            scrollDirection = _a === void 0 ? DIRECTION.VERTICAL : _a;
        var _b = this.sizeAndPositionManager.getSizeAndPositionForIndex(index),
            size = _b.size,
            offset = _b.offset;
        return this.styleCache[index] = sticky ? __assign$1({}, STYLE_STICKY_ITEM, (_c = {}, _c[sizeProp[scrollDirection]] = size, _c[marginProp[scrollDirection]] = offset, _c[oppositeMarginProp[scrollDirection]] = -(offset + size), _c.zIndex = 1, _c)) : __assign$1({}, STYLE_ITEM, (_d = {}, _d[sizeProp[scrollDirection]] = size, _d[positionProp[scrollDirection]] = offset, _d));
        var _c, _d;
    };
    VirtualList.defaultProps = {
        overscanCount: 3,
        scrollDirection: DIRECTION.VERTICAL,
        width: '100%'
    };
    VirtualList.propTypes = {
        estimatedItemSize: number,
        height: oneOfType([number, string]).isRequired,
        itemCount: number.isRequired,
        itemSize: oneOfType([number, array, func]).isRequired,
        onScroll: func,
        onItemsRendered: func,
        overscanCount: number,
        renderItem: func.isRequired,
        scrollOffset: number,
        scrollToIndex: number,
        scrollToAlignment: oneOf([ALIGNMENT.AUTO, ALIGNMENT.START, ALIGNMENT.CENTER, ALIGNMENT.END]),
        scrollDirection: oneOf([DIRECTION.HORIZONTAL, DIRECTION.VERTICAL]),
        stickyIndices: arrayOf(number),
        style: object,
        width: oneOfType([number, string])
    };
    return VirtualList;
}(PureComponent);

var ListType;
(function (ListType) {
    ListType[ListType["unselected"] = 0] = "unselected";
    ListType[ListType["selected"] = 1] = "selected";
})(ListType || (ListType = {}));
var DesktopList = /** @class */ (function (_super) {
    __extends(DesktopList, _super);
    function DesktopList(props) {
        var _this = _super.call(this, props) || this;
        _this.onSelectItem = function (selectedIndex) {
            var selectedOptions = __spreadArrays(_this.props.selectedOptions);
            selectedOptions.push(_this.props.options.filter(function (u) { return !selectedOptions.find(function (s) { return u.value === s.value; }); })[selectedIndex]);
            _this.props.onChange(selectedOptions);
            if (_this.props.onFocus) {
                _this.props.onFocus();
            }
            _this.setState({ acvtiveUnselectedItem: 0 });
        };
        _this.onDeselectItem = function (unSelectedIndex) {
            var selectedOptions = __spreadArrays(_this.props.selectedOptions);
            selectedOptions.splice(unSelectedIndex, 1);
            _this.props.onChange(selectedOptions);
            if (selectedOptions.length === 0) {
                if (_this.props.onBlur) {
                    _this.props.onBlur();
                }
                _this.setState({
                    acvtiveSelectedItem: -1,
                    currentList: selectedOptions.length === 0 ? ListType.unselected : _this.state.currentList
                });
            }
            else {
                _this.setState({
                    acvtiveSelectedItem: 0,
                    currentList: selectedOptions.length === 0 ? ListType.unselected : _this.state.currentList
                });
            }
        };
        _this.onDeselectAll = function () {
            _this.props.onChange([]);
            _this.setState({ currentList: ListType.unselected, acvtiveSelectedItem: 0 });
        };
        _this.handleKeyPress = function (e) {
            var _a = _this.props, selectedOptions = _a.selectedOptions, options = _a.options;
            var _b = _this.state, currentList = _b.currentList, acvtiveSelectedItem = _b.acvtiveSelectedItem, acvtiveUnselectedItem = _b.acvtiveUnselectedItem;
            var list;
            if (currentList === ListType.unselected) {
                list = document.querySelector(".multiple-select_list--unselected--virutual");
            }
            else {
                list = document.querySelector(".multiple-select_list--selected--virutual");
            }
            var activeItem = list.querySelector(".js-active");
            if (!activeItem) {
                return;
            }
            switch (e.key) {
                case "Enter":
                    if (currentList === ListType.unselected) {
                        _this.onSelectItem(acvtiveUnselectedItem);
                    }
                    else {
                        _this.onDeselectItem(acvtiveSelectedItem);
                    }
                    break;
                case "ArrowUp":
                    list.scrollTop = activeItem.offsetTop;
                    if (currentList === ListType.unselected && acvtiveUnselectedItem > 0) {
                        _this.setState({ acvtiveUnselectedItem: acvtiveUnselectedItem - 1 });
                    }
                    else if (acvtiveSelectedItem > 0) {
                        _this.setState({ acvtiveSelectedItem: acvtiveSelectedItem - 1 });
                    }
                    break;
                case "ArrowDown":
                    list.scrollTop = activeItem.offsetTop;
                    if (currentList === ListType.unselected && (acvtiveUnselectedItem + 1) < options
                        .filter(function (u) { return !selectedOptions.find(function (s) { return u.value === s.value; }); }).length) {
                        _this.setState({ acvtiveUnselectedItem: acvtiveUnselectedItem + 1 });
                    }
                    else if (currentList === ListType.selected && (acvtiveSelectedItem + 1) < selectedOptions.length) {
                        _this.setState({ acvtiveSelectedItem: acvtiveSelectedItem + 1 });
                    }
                    break;
                case "ArrowRight":
                    if (selectedOptions.length > 0 && currentList === ListType.unselected) {
                        _this.setState({ currentList: ListType.selected, acvtiveSelectedItem: 0, acvtiveUnselectedItem: 1 });
                    }
                    break;
                case "ArrowLeft":
                    if (options
                        .filter(function (u) { return !selectedOptions.find(function (s) { return u.value === s.value; }); }).length > 0 && currentList === ListType.selected) {
                        _this.setState({ currentList: ListType.unselected, acvtiveSelectedItem: -1, acvtiveUnselectedItem: 0 });
                    }
                    break;
                case "Escape":
                    break;
            }
        };
        _this.unSelectedRow = function (_a) {
            var index = _a.index, style = _a.style;
            var renderUnSelectedOption = _this.props.renderUnSelectedOption;
            var _b = _this.state, currentList = _b.currentList, acvtiveUnselectedItem = _b.acvtiveUnselectedItem, unSelectedList = _b.unSelectedList;
            return (createElement("div", { style: style, key: index, className: "multiple-select_list_item" + (currentList === ListType.unselected && acvtiveUnselectedItem === index ? " js-active" : "") },
                "\t\t\t\t",
                createElement("li", { onClick: function () { return _this.onSelectItem(index); }, role: "option" }, renderUnSelectedOption ? renderUnSelectedOption(unSelectedList[index]) : createElement("span", null, unSelectedList[index].label))));
        };
        _this.selectedRow = function (_a) {
            var index = _a.index, style = _a.style;
            var _b = _this.props, renderSelectedOption = _b.renderSelectedOption, selectedOptions = _b.selectedOptions;
            var _c = _this.state, currentList = _c.currentList, acvtiveSelectedItem = _c.acvtiveSelectedItem;
            return (createElement("div", { style: style, key: index, className: "multiple-select_list_item" + (currentList === ListType.selected && acvtiveSelectedItem === index ? " js-active" : "") },
                createElement("li", { onClick: function () { return _this.onDeselectItem(index); } }, renderSelectedOption ? renderSelectedOption(selectedOptions[index]) : createElement(Fragment, null,
                    createElement("span", null, selectedOptions[index].label),
                    createElement(TrashIcon, null)))));
        };
        var isAllSelected = props.selectedOptions.length === props.options.length;
        _this.state = {
            acvtiveUnselectedItem: isAllSelected ? -1 : 0,
            acvtiveSelectedItem: isAllSelected ? 0 : -1,
            unSelectedList: props.options.filter(function (u) { return !props.selectedOptions.find(function (s) { return u.value === s.value; }); }),
            currentList: isAllSelected ? ListType.selected : ListType.unselected,
            selectedOptionsLength: props.selectedOptions.length
        };
        return _this;
    }
    DesktopList.getDerivedStateFromProps = function (props, state) {
        if (props.selectedOptions.length !== state.selectedOptionsLength) {
            return __assign(__assign({}, state), { unSelectedList: props.options
                    .filter(function (u) { return !props.selectedOptions.find(function (s) { return u.value === s.value; }); }), selectedOptionsLength: props.selectedOptions.length });
        }
        else {
            return state;
        }
    };
    DesktopList.prototype.componentDidMount = function () {
        window.addEventListener("keydown", this.handleKeyPress);
    };
    DesktopList.prototype.componentWillUnmount = function () {
        window.removeEventListener("keydown", this.handleKeyPress);
    };
    DesktopList.prototype.render = function () {
        var _a = this.props, selectedOptions = _a.selectedOptions, addable = _a.addable, theme = _a.theme;
        var unSelectedList = (createElement("div", { className: "multiple-select_list multiple-select_list--unselected" + (addable ? " js-addable" : ""), role: "listbox", "aria-labelledby": "ss_elem" },
            createElement(VirtualList, { height: 200, itemCount: this.state.unSelectedList.length, itemSize: 40, width: 240, style: { overflowY: 'auto', overflowX: 'initial' }, className: "multiple-select_list--unselected--virutual", renderItem: this.unSelectedRow })));
        var selectedList = (createElement("div", { className: "multiple-select_list multiple-select_list--selected" },
            createElement(VirtualList, { height: 200, itemCount: selectedOptions.length, itemSize: 40, width: 240, style: { overflowY: 'auto', overflowX: 'initial' }, className: "multiple-select_list--selected--virutual", renderItem: this.selectedRow })));
        return (createElement("div", { className: 'multiple-select_lists' + ' ' + theme, style: { width: !!selectedOptions.length ? 480 : 240 } },
            createElement("div", { className: "multiple-select_lists_inner" },
                unSelectedList,
                !!selectedOptions.length && selectedList)));
    };
    DesktopList.defaultProps = {
        theme: "default"
    };
    return DesktopList;
}(Component));

var ListType$1;
(function (ListType$$1) {
    ListType$$1[ListType$$1["unselected"] = 0] = "unselected";
    ListType$$1[ListType$$1["selected"] = 1] = "selected";
})(ListType$1 || (ListType$1 = {}));
var MultipleSelect = /** @class */ (function (_super) {
    __extends(MultipleSelect, _super);
    function MultipleSelect(props) {
        var _this = _super.call(this, props) || this;
        _this.inputRef = createRef();
        _this.selectWrapRef = createRef();
        _this.handleClickOutside = function (e) {
            if (e.target.closest(".multiple-select_dropdown_wrap")) {
                return;
            }
            if (_this.inputRef.current) {
                _this.inputRef.current.value = "";
            }
            if (_this.state.showLists) {
                _this.setState({ showLists: false });
            }
        };
        _this.onFocus = function () {
            var onFocus = _this.props.onFocus;
            if (_this.inputRef.current) {
                _this.inputRef.current.focus();
            }
            _this.setState({ showLists: true });
            if (onFocus) {
                onFocus();
            }
        };
        _this.onBlur = function () {
            var onBlur = _this.props.onBlur;
            if (_this.inputRef.current) {
                _this.inputRef.current.value = "";
            }
            if (onBlur) {
                onBlur();
            }
        };
        var isAllSelected = props.selectedOptions.length === props.options.length;
        _this.state = {
            showLists: false,
        };
        return _this;
    }
    MultipleSelect.prototype.componentDidMount = function () {
        document.addEventListener('mousedown', this.handleClickOutside);
        document.addEventListener('touchstart', this.handleClickOutside);
    };
    MultipleSelect.prototype.componentWillUnmount = function () {
        document.removeEventListener('mousedown', this.handleClickOutside);
        document.removeEventListener('touchstart', this.handleClickOutside);
    };
    MultipleSelect.prototype.render = function () {
        var _a = this.props, onInputChange = _a.onInputChange, selectedOptions = _a.selectedOptions, addable = _a.addable, theme = _a.theme;
        var showLists = this.state.showLists;
        return (createElement("div", { className: "multiple-select_wrap", ref: this.selectWrapRef },
            createElement("div", { className: "multiple-select_summary_wrap", hidden: showLists || selectedOptions.length < 1 },
                createElement("span", { onClick: this.onFocus },
                    selectedOptions.length > 0 ? selectedOptions[0].label : "",
                    selectedOptions.length > 1 && "...")),
            createElement("div", { className: "multiple-select_trigger" },
                createElement("input", { onChange: function (e) {
                        if (onInputChange) {
                            onInputChange(e.target.value);
                        }
                    }, onFocus: this.onFocus, onBlur: this.onBlur, ref: this.inputRef })),
            showLists && createElement(DropDownWrap, { className: "multiple-select_dropdown_wrap", top: this.selectWrapRef.current ? this.selectWrapRef.current.clientHeight : 0 },
                createElement(DesktopList, __assign({}, this.props, { onBlur: this.onBlur, onFocus: this.onFocus })))));
    };
    MultipleSelect.defaultProps = {
        theme: "default"
    };
    return MultipleSelect;
}(Component));

var SelectedList = function (_a) {
    var selectedOptions = _a.selectedOptions, selectedRow = _a.selectedRow;
    return (createElement("div", { className: "multiple-select_list multiple-select_list--selected" },
        createElement(VirtualList, { height: 200, itemCount: selectedOptions.length, itemSize: 40, width: 240, style: { overflowY: 'auto', overflowX: 'initial' }, className: "multiple-select_list--selected--virutual", renderItem: selectedRow })));
};

var UnSelectedList = function (_a) {
    var unSelectedList = _a.unSelectedList, unSelectedRow = _a.unSelectedRow;
    return (createElement("div", { className: "multiple-select_list multiple-select_list--unselected", role: "listbox", "aria-labelledby": "ss_elem" },
        createElement(VirtualList, { height: 200, itemCount: unSelectedList.length, itemSize: 40, width: 240, style: { overflowY: 'auto', overflowX: 'initial' }, className: "multiple-select_list--unselected--virutual", renderItem: unSelectedRow })));
};

var MobileList = /** @class */ (function (_super) {
    __extends(MobileList, _super);
    function MobileList(props) {
        var _this = _super.call(this, props) || this;
        _this.inputRef = createRef();
        _this.isFirstTimeSelectedListDisplay = false;
        _this.isFirstTimeUnSelectedListDisplay = false;
        _this.handleClickOutside = function (e) {
            if (e.target.closest("#popper-portal")) {
                return;
            }
            if (_this.inputRef.current) {
                _this.inputRef.current.value = "";
            }
            if (_this.state.showLists) {
                _this.setState({ showLists: false });
            }
        };
        _this.onSelectItem = function (selectedIndex) {
            var _a = _this.props, options = _a.options, onChange = _a.onChange;
            var selectedOptions = __spreadArrays(_this.props.selectedOptions);
            selectedOptions.push(options.filter(function (u) { return !selectedOptions.find(function (s) { return u.value === s.value; }); })[selectedIndex]);
            onChange(selectedOptions);
        };
        _this.onDeselectItem = function (unSelectedIndex) {
            var selectedOptions = __spreadArrays(_this.props.selectedOptions);
            selectedOptions.splice(unSelectedIndex, 1);
            _this.props.onChange(selectedOptions);
            if (selectedOptions.length === 0) {
                if (_this.props.onBlur) {
                    _this.props.onBlur();
                }
            }
        };
        _this.onDeselectAll = function () {
            _this.props.onChange([]);
        };
        _this.unSelectedRow = function (_a) {
            var index = _a.index, style = _a.style;
            var renderUnSelectedOption = _this.props.renderUnSelectedOption;
            var unSelectedList = _this.state.unSelectedList;
            return (createElement("div", { style: style, key: index, className: "multiple-select_list_item" },
                createElement("li", { onClick: function () { return _this.onSelectItem(index); }, role: "option" }, renderUnSelectedOption ? renderUnSelectedOption(unSelectedList[index]) : createElement("span", null, unSelectedList[index].label))));
        };
        _this.selectedRow = function (_a) {
            var index = _a.index, style = _a.style;
            var _b = _this.props, renderSelectedOption = _b.renderSelectedOption, selectedOptions = _b.selectedOptions;
            return (createElement("div", { style: style, key: index, className: "multiple-select_list_item" },
                createElement("li", { onClick: function () { return _this.onDeselectItem(index); } }, renderSelectedOption ? renderSelectedOption(selectedOptions[index]) : createElement(Fragment, null,
                    createElement("span", null, selectedOptions[index].label),
                    createElement(TrashIcon, null)))));
        };
        _this.state = {
            showLists: false,
            currentTab: "unselected",
            unSelectedList: props.options,
            selectedOptionsLength: props.selectedOptions.length
        };
        return _this;
    }
    MobileList.getDerivedStateFromProps = function (props, state) {
        if (props.selectedOptions.length !== state.selectedOptionsLength) {
            return __assign(__assign({}, state), { unSelectedList: props.options
                    .filter(function (u) { return !props.selectedOptions.find(function (s) { return u.value === s.value; }); }), selectedOptionsLength: props.selectedOptions.length });
        }
        else {
            return state;
        }
    };
    MobileList.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _this = this;
        var xDown = null;
        var yDown = null;
        var timeout;
        var longtouch;
        var whereDidSwipe = 'didnot';
        function getTouches(evt) {
            return evt.touches || // browser API
                evt.originalEvent.touches; // jQuery
        }
        function handleTouchStart(evt) {
            var firstTouch = getTouches(evt)[0];
            xDown = firstTouch.clientX;
            yDown = firstTouch.clientY;
            timeout = setTimeout(function () {
                longtouch = true;
            }, 100);
        }
        var handleToucEnd = function () {
            if (longtouch) {
                switch (whereDidSwipe) {
                    case 'left':
                        _this.setState({ currentTab: 'selected' });
                        whereDidSwipe = 'didnot';
                        break;
                    case 'right':
                        _this.setState({ currentTab: 'unselected' });
                        whereDidSwipe = 'didnot';
                        break;
                    case 'didnot':
                    default:
                }
            }
            longtouch = false;
            clearTimeout(timeout);
        };
        var handleTouchMove = function (evt) {
            if (!xDown || !yDown) {
                return;
            }
            var xUp = evt.touches[0].clientX;
            var yUp = evt.touches[0].clientY;
            var xDiff = xDown - xUp;
            var yDiff = yDown - yUp;
            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                if (xDiff > 0) {
                    whereDidSwipe = 'left';
                }
                else {
                    whereDidSwipe = 'right';
                }
            }
            xDown = null;
            yDown = null;
        };
        var addEventListenersToUnselectedList = function () {
            // @ts-ignore
            document.querySelector(".multiple-select_list--unselected--virutual").addEventListener('touchstart', handleTouchStart, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--unselected--virutual").addEventListener('touchmove', handleTouchMove, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--unselected--virutual").addEventListener('touchend', handleToucEnd, false);
        };
        var addEventListenersToSelectedList = function () {
            // @ts-ignore
            document.querySelector(".multiple-select_list--selected--virutual").addEventListener('touchstart', handleTouchStart, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--selected--virutual").addEventListener('touchmove', handleTouchMove, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--selected--virutual").addEventListener('touchend', handleToucEnd, false);
        };
        if (this.state.showLists && !prevState.showLists) {
            addEventListenersToUnselectedList();
        }
        if (this.state.currentTab !== prevState.currentTab) {
            if (this.state.currentTab === 'selected') {
                addEventListenersToSelectedList();
            }
            if (this.state.currentTab === 'unselected') {
                addEventListenersToUnselectedList();
            }
        }
    };
    MobileList.prototype.componentDidMount = function () {
        document.addEventListener('mousedown', this.handleClickOutside);
        document.addEventListener('touchstart', this.handleClickOutside);
    };
    MobileList.prototype.componentWillUnmount = function () {
        document.removeEventListener('mousedown', this.handleClickOutside);
        document.removeEventListener('touchstart', this.handleClickOutside);
    };
    MobileList.prototype.render = function () {
        var _this = this;
        var _a = this.props, selectedTabLabel = _a.selectedTabLabel, unselectedTabLabel = _a.unselectedTabLabel, selectedOptions = _a.selectedOptions;
        var _b = this.state, currentTab = _b.currentTab, unSelectedList = _b.unSelectedList;
        return (createElement("div", { className: "multiple-select_lists", style: { width: 240 } },
            createElement("div", { className: "multiple-select_tab_header" },
                createElement("div", { className: "multiple-select_tab_header_item" + (currentTab === "unselected" ? " js-active" : ""), onClick: function () { _this.setState({ currentTab: "unselected" }); } },
                    createElement("span", null, unselectedTabLabel)),
                createElement("div", { className: "multiple-select_tab_header_item" + (currentTab === "selected" ? " js-active" : ""), onClick: function () { _this.setState({ currentTab: "selected" }); } },
                    createElement("span", null, selectedTabLabel))),
            currentTab === "unselected" ?
                createElement("div", null,
                    createElement(UnSelectedList, { unSelectedList: unSelectedList, unSelectedRow: this.unSelectedRow }))
                : createElement("div", null,
                    createElement(SelectedList, { selectedOptions: selectedOptions, selectedRow: this.selectedRow }))));
    };
    MobileList.defaultProps = {
        selectedTabLabel: "selected",
        unselectedTabLabel: "unselected"
    };
    return MobileList;
}(Component));

var MultipleSelect$1 = /** @class */ (function (_super) {
    __extends(MultipleSelect, _super);
    function MultipleSelect(props) {
        var _this = _super.call(this, props) || this;
        _this.isFirstTimeSelectedListDisplay = false;
        _this.isFirstTimeUnSelectedListDisplay = false;
        _this.inputRef = createRef();
        _this.selectWrapRef = createRef();
        _this.handleClickOutside = function (e) {
            if (e.target.closest(".multiple-select_dropdown_wrap")) {
                return;
            }
            if (_this.inputRef.current) {
                _this.inputRef.current.value = "";
            }
            if (_this.state.showLists) {
                _this.setState({ showLists: false });
            }
        };
        _this.onSelectItem = function (selectedIndex) {
            var _a = _this.props, options = _a.options, onChange = _a.onChange;
            var selectedOptions = __spreadArrays(_this.props.selectedOptions);
            selectedOptions.push(options.filter(function (u) { return !selectedOptions.find(function (s) { return u.value === s.value; }); })[selectedIndex]);
            onChange(selectedOptions);
            if (_this.props.onFocus) {
                _this.props.onFocus;
            }
        };
        _this.onDeselectItem = function (unSelectedIndex) {
            var selectedOptions = __spreadArrays(_this.props.selectedOptions);
            selectedOptions.splice(unSelectedIndex, 1);
            _this.props.onChange(selectedOptions);
            if (selectedOptions.length === 0) {
                _this.onBlur();
            }
        };
        _this.onDeselectAll = function () {
            _this.props.onChange([]);
        };
        _this.onFocus = function () {
            var onFocus = _this.props.onFocus;
            if (_this.inputRef.current) {
                _this.inputRef.current.focus();
            }
            _this.setState({ showLists: true });
            if (onFocus) {
                onFocus();
            }
        };
        _this.onBlur = function () {
            var onBlur = _this.props.onBlur;
            if (_this.inputRef.current) {
                _this.inputRef.current.value = "";
            }
            if (onBlur) {
                onBlur();
            }
        };
        _this.state = {
            showLists: false,
            currentTab: "unselected",
            unSelectedList: props.options,
            selectedOptionsLength: props.selectedOptions.length
        };
        return _this;
    }
    MultipleSelect.getDerivedStateFromProps = function (props, state) {
        if (props.selectedOptions.length !== state.selectedOptionsLength) {
            return __assign(__assign({}, state), { unSelectedList: props.options
                    .filter(function (u) { return !props.selectedOptions.find(function (s) { return u.value === s.value; }); }), selectedOptionsLength: props.selectedOptions.length });
        }
        else {
            return state;
        }
    };
    MultipleSelect.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _this = this;
        var xDown = null;
        var yDown = null;
        var timeout;
        var longtouch;
        var whereDidSwipe = 'didnot';
        function getTouches(evt) {
            return evt.touches || // browser API
                evt.originalEvent.touches; // jQuery
        }
        function handleTouchStart(evt) {
            var firstTouch = getTouches(evt)[0];
            xDown = firstTouch.clientX;
            yDown = firstTouch.clientY;
            timeout = setTimeout(function () {
                longtouch = true;
            }, 100);
        }
        var handleToucEnd = function () {
            if (longtouch) {
                switch (whereDidSwipe) {
                    case 'left':
                        _this.setState({ currentTab: 'selected' });
                        whereDidSwipe = 'didnot';
                        break;
                    case 'right':
                        _this.setState({ currentTab: 'unselected' });
                        whereDidSwipe = 'didnot';
                        break;
                    case 'didnot':
                    default:
                }
            }
            longtouch = false;
            clearTimeout(timeout);
        };
        var handleTouchMove = function (evt) {
            if (!xDown || !yDown) {
                return;
            }
            var xUp = evt.touches[0].clientX;
            var yUp = evt.touches[0].clientY;
            var xDiff = xDown - xUp;
            var yDiff = yDown - yUp;
            if (Math.abs(xDiff) > Math.abs(yDiff)) {
                if (xDiff > 0) {
                    whereDidSwipe = 'left';
                }
                else {
                    whereDidSwipe = 'right';
                }
            }
            xDown = null;
            yDown = null;
        };
        var addEventListenersToUnselectedList = function () {
            // @ts-ignore
            document.querySelector(".multiple-select_list--unselected--virutual").addEventListener('touchstart', handleTouchStart, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--unselected--virutual").addEventListener('touchmove', handleTouchMove, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--unselected--virutual").addEventListener('touchend', handleToucEnd, false);
        };
        var addEventListenersToSelectedList = function () {
            // @ts-ignore
            document.querySelector(".multiple-select_list--selected--virutual").addEventListener('touchstart', handleTouchStart, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--selected--virutual").addEventListener('touchmove', handleTouchMove, false);
            // @ts-ignore
            document.querySelector(".multiple-select_list--selected--virutual").addEventListener('touchend', handleToucEnd, false);
        };
        if (this.state.showLists && !prevState.showLists) {
            addEventListenersToUnselectedList();
        }
        if (this.state.currentTab !== prevState.currentTab) {
            if (this.state.currentTab === 'selected') {
                addEventListenersToSelectedList();
            }
            if (this.state.currentTab === 'unselected') {
                addEventListenersToUnselectedList();
            }
        }
    };
    MultipleSelect.prototype.componentDidMount = function () {
        document.addEventListener('mousedown', this.handleClickOutside);
        document.addEventListener('touchstart', this.handleClickOutside);
    };
    MultipleSelect.prototype.componentWillUnmount = function () {
        document.removeEventListener('mousedown', this.handleClickOutside);
        document.removeEventListener('touchstart', this.handleClickOutside);
    };
    MultipleSelect.prototype.render = function () {
        var _a = this.props, onInputChange = _a.onInputChange, selectedOptions = _a.selectedOptions;
        var showLists = this.state.showLists;
        return (createElement("div", { className: "multiple-select_wrap", ref: this.selectWrapRef },
            createElement("div", { className: "multiple-select_summary_wrap", hidden: showLists || selectedOptions.length < 1 },
                createElement("span", { className: "multiple-select_summary", onClick: this.onFocus },
                    selectedOptions.length > 0 ? selectedOptions[0].label : "",
                    selectedOptions.length > 1 && "...")),
            createElement("div", { className: "multiple-select_trigger" },
                createElement("input", { onChange: function (e) {
                        if (onInputChange) {
                            onInputChange(e.target.value);
                        }
                    }, onFocus: this.onFocus, onBlur: this.onBlur, ref: this.inputRef })),
            showLists && createElement(DropDownWrap, { className: "multiple-select_dropdown_wrap", top: this.selectWrapRef.current ? this.selectWrapRef.current.clientHeight : 0 },
                createElement(MobileList, __assign({}, this.props, { onBlur: this.onBlur, onFocus: this.onFocus })))));
    };
    MultipleSelect.defaultProps = {
        selectedTabLabel: "selected",
        unselectedTabLabel: "unselected"
    };
    return MultipleSelect;
}(Component));

var MultipleSelect$2 = function (props) { return (createElement(Fragment, null,
    createElement("div", { className: "multiple-select--desktop" },
        createElement(MultipleSelect, __assign({}, props, { direction: props.direction || "rtl" }))),
    createElement("div", { className: "multiple-select--mobile" },
        createElement(MultipleSelect$1, __assign({}, props))))); };

export default MultipleSelect$2;
export { DesktopList, MobileList };
//# sourceMappingURL=index.es.js.map
